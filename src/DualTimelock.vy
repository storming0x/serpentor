# @version 0.3.7

"""
@title Yearn Dual Time lock implementation
@license GNU AGPLv3
@author yearn.finance
@notice
    A timelock contract implementation in vyper that manages two queues with different delay configurations. 
    The first queue is for governance actions compatible with other governor type systems, and the second queue is for faster operational actions.
    The operational actions will be used for actions that are not critical to the protocol, but are still
    time sensitive. The governance actions will be used for actions that are critical to the protocol, 
    and require a larger delay.
    Designed to work with most governance voting contracts and close integration
    with SerpentorBravo.
    The second queue for operational actions is used for fast tracking actions that are generated by pre-approved contracts
    with limited access and very specific functionality.
"""

event NewAdmin:
    newAdmin: indexed(address)

event NewLeanTrack:
    newLeanTrack: indexed(address)

event NewPendingAdmin:
    newPendingAdmin: indexed(address)

event NewPendingLeanTrack:
    newPendingLeanTrack: indexed(address)

event NewDelay:
    newDelay: uint256

event NewLeanTrackDelay:
    newLeanTrackDelay: uint256

event CancelTransaction:
    txHash: indexed(bytes32)
    target: indexed(address)
    value: uint256
    signature: String[METHOD_SIG_SIZE]
    data: Bytes[CALL_DATA_LEN]
    eta: uint256

event ExecuteTransaction:
    txHash: indexed(bytes32)
    target: indexed(address)
    value: uint256
    signature: String[METHOD_SIG_SIZE]
    data: Bytes[CALL_DATA_LEN]
    eta: uint256

event QueueTransaction:
    txHash: indexed(bytes32)
    target: indexed(address)
    value: uint256
    signature: String[METHOD_SIG_SIZE]
    data: Bytes[CALL_DATA_LEN]
    eta: uint256

event QueueRapidTransaction:
    txHash: indexed(bytes32)
    target: indexed(address)
    value: uint256
    signature: String[METHOD_SIG_SIZE]
    data: Bytes[CALL_DATA_LEN]
    eta: uint256

event CancelRapidTransaction:
    txHash: indexed(bytes32)
    target: indexed(address)
    value: uint256
    signature: String[METHOD_SIG_SIZE]
    data: Bytes[CALL_DATA_LEN]
    eta: uint256

event ExecuteRapidTransaction:
    txHash: indexed(bytes32)
    target: indexed(address)
    value: uint256
    signature: String[METHOD_SIG_SIZE]
    data: Bytes[CALL_DATA_LEN]
    eta: uint256

MAX_DATA_LEN: constant(uint256) = 16608
CALL_DATA_LEN: constant(uint256) = 16483
METHOD_SIG_SIZE: constant(uint256) = 1024
DAY: constant(uint256) = 86400
GRACE_PERIOD: constant(uint256) = 14 * DAY
MINIMUM_DELAY: constant(uint256) = 2 * DAY
MAXIMUM_DELAY: constant(uint256) = 30 * DAY

admin: public(address)
pendingAdmin: public(address)
delay: public(uint256)
queuedTransactions: public(HashMap[bytes32,  bool])

leanTrack: public(address)
pendingLeanTrack: public(address)
leanTrackDelay: public(uint256)
queuedRapidTransactions: public(HashMap[bytes32,  bool])

@external
def __init__(admin: address, leanTrack: address, delay: uint256, leanTrackDelay: uint256):
    """
    @notice Deploys the timelock with initial values
    @param admin The contract that rules over the timelock
    @param leanTrack The contract that rules over the lean track queued transactions. Can be 0x0.
    @param delay The delay for timelock
    @param leanTrackDelay The delay for lean track timelock
    """

    assert delay >= MINIMUM_DELAY, "Delay must exceed minimum delay"
    assert delay <= MAXIMUM_DELAY, "Delay must not exceed maximum delay"
    assert delay > leanTrackDelay, "Delay must be greater than lean track delay"
    assert admin != empty(address), "!admin"
    self.admin = admin
    self.leanTrack = leanTrack
    self.delay = delay
    self.leanTrackDelay = leanTrackDelay


@external
@payable
def __default__():
    pass

@external
def setDelay(delay: uint256):
    """
    @notice
        Updates delay to new value
    @param delay The delay for timelock
    """
    assert msg.sender == self, "!Timelock"
    assert delay >= MINIMUM_DELAY, "!MINIMUM_DELAY"
    assert delay <= MAXIMUM_DELAY, "!MAXIMUM_DELAY"
    self.delay = delay

    log NewDelay(delay)

@external
def setLeanTrackDelay(leanTrackDelay: uint256):
    """
    @notice
        Updates lean track delay to new value
    @param leanTrackDelay The delay for lean track timelock
    """
    assert msg.sender == self, "!Timelock"
    assert leanTrackDelay < self.delay, "!leanTrackDelay < delay"
    self.leanTrackDelay = leanTrackDelay

    log NewLeanTrackDelay(leanTrackDelay)

@external
def acceptAdmin():
    """
    @notice
        updates `pendingAdmin` to admin.
        msg.sender must be `pendingAdmin`
    """
    assert msg.sender == self.pendingAdmin, "!pendingAdmin"
    self.admin = msg.sender
    self.pendingAdmin = empty(address)

    log NewAdmin(msg.sender)
    log NewPendingAdmin(empty(address))

@external
def setPendingAdmin(pendingAdmin: address):
    """
    @notice
       Updates `pendingAdmin` value
       msg.sender must be this contract
    @param pendingAdmin The proposed new admin for the contract
    """
    assert msg.sender == self, "!Timelock"
    self.pendingAdmin = pendingAdmin

    log NewPendingAdmin(pendingAdmin)

@external 
def acceptLeanTrack():
    """
    @notice
        updates `pendingLeanTrack` to leanTrack.
        msg.sender must be `pendingLeanTrack`
    """
    assert msg.sender == self.pendingLeanTrack, "!pendingLeanTrack"
    self.leanTrack = msg.sender
    self.pendingLeanTrack = empty(address)
    log NewLeanTrack(msg.sender)
    log NewPendingLeanTrack(empty(address))
    

@external
def setPendingLeanTrack(pendingLeanTrack: address):
    """
    @notice
       Updates `pendingLeanTrack` value
       msg.sender must be this contract
    @param pendingLeanTrack The proposed new lean track contract for the contract
    """
    assert msg.sender == self, "!Timelock"
    self.pendingLeanTrack = pendingLeanTrack

    log NewPendingLeanTrack(pendingLeanTrack)

@external
def queueTransaction(
    target: address,
    amount: uint256,
    signature: String[METHOD_SIG_SIZE],
    data: Bytes[CALL_DATA_LEN],
    eta: uint256
) -> bytes32:
    """
    @notice
        adds transaction to execution queue
    @param target The address of the contract to execute
    @param amount The amount of ether to send to the contract
    @param signature The signature of the function to execute
    @param data The data to send to the contract
    @param eta The timestamp when the transaction can be executed

    @return txHash The hash of the transaction
    """
    assert msg.sender == self.admin, "!admin"
    assert eta >= block.timestamp + self.delay, "!eta"

    trxHash: bytes32 = keccak256(_abi_encode(target, amount, signature, data, eta))
    self.queuedTransactions[trxHash] = True

    log QueueTransaction(trxHash, target, amount, signature, data, eta)

    return trxHash

@external
def cancelTransaction(
    target: address,
    amount: uint256,
    signature: String[METHOD_SIG_SIZE],
    data: Bytes[CALL_DATA_LEN],
    eta: uint256
):
    """
    @notice
        cancels a queued transaction
    @param target The address of the contract to execute
    @param amount The amount of ether to send to the contract
    @param signature The signature of the function to execute
    @param data The data to send to the contract
    @param eta The timestamp when the transaction can be executed
    """
    assert msg.sender == self.admin, "!admin"

    trxHash: bytes32 = keccak256(_abi_encode(target, amount, signature, data, eta))
    self.queuedTransactions[trxHash] = False

    log CancelTransaction(trxHash, target, amount, signature, data, eta)

@payable
@external
def executeTransaction(
    target: address,
    amount: uint256,
    signature: String[METHOD_SIG_SIZE],
    data: Bytes[CALL_DATA_LEN],
    eta: uint256
) -> Bytes[MAX_DATA_LEN]:
    """
    @notice
        executes a queued transaction
    @param target The address of the contract to execute
    @param amount The amount of ether to send to the contract
    @param signature The signature of the function to execute
    @param data The data to send to the contract
    @param eta The timestamp when the transaction can be executed

    @return response The response from the transaction
    """
    assert msg.sender == self.admin, "!admin"

    trxHash: bytes32 = keccak256(_abi_encode(target, amount, signature, data, eta))
    assert self.queuedTransactions[trxHash], "!queued_trx"
    assert block.timestamp >= eta, "!eta"
    assert block.timestamp <= eta + GRACE_PERIOD, "!staled_trx"

    self.queuedTransactions[trxHash] = False

    callData: Bytes[MAX_DATA_LEN] = b""

    if len(signature) == 0:
        # @dev use provided data directly
        callData = data
    else: 
        # @dev use signature + data
        sig_hash: bytes32 = keccak256(signature)
        func_sig: bytes4 = convert(slice(sig_hash, 0, 4), bytes4)
        callData = concat(func_sig, data)

    success: bool = False
    response: Bytes[MAX_DATA_LEN] = b""

    success, response = raw_call(
        target,
        callData,
        max_outsize=MAX_DATA_LEN,
        value=amount,
        revert_on_failure=False
    )

    assert success, "!trx_revert"

    log ExecuteTransaction(trxHash, target, amount, signature, data, eta)

    return response

@external
def queueRapidTransaction(
    target: address,
    amount: uint256,
    signature: String[METHOD_SIG_SIZE],
    data: Bytes[CALL_DATA_LEN],
    eta: uint256
) -> bytes32:
    """
    @notice
        adds transaction to rapid execution queue
        rapid execution queue cannot target this timelock contract
    @param target The address of the contract to execute
    @param amount The amount of ether to send to the contract
    @param signature The signature of the function to execute
    @param data The data to send to the contract
    @param eta The timestamp when the transaction can be executed

    @return txHash The hash of the transaction
    """
    # @dev minor gas savings
    leanTrack: address = self.leanTrack
    assert msg.sender == leanTrack, "!leanTrack"
    assert target != leanTrack, "!target"
    assert target != self, "!target"
    assert target != self.admin, "!target"
    assert eta >= block.timestamp + self.leanTrackDelay, "!eta"

    trxHash: bytes32 = keccak256(_abi_encode(target, amount, signature, data, eta))
    self.queuedRapidTransactions[trxHash] = True

    log QueueRapidTransaction(trxHash, target, amount, signature, data, eta)

    return trxHash

@external
def cancelRapidTransaction(
    target: address,
    amount: uint256,
    signature: String[METHOD_SIG_SIZE],
    data: Bytes[CALL_DATA_LEN],
    eta: uint256
):
    """
    @notice
        cancels a queued rapid transaction
    @param target The address of the contract to execute
    @param amount The amount of ether to send to the contract
    @param signature The signature of the function to execute
    @param data The data to send to the contract
    @param eta The timestamp when the transaction can be executed
    """
    assert msg.sender == self.leanTrack, "!leanTrack"

    trxHash: bytes32 = keccak256(_abi_encode(target, amount, signature, data, eta))
    self.queuedRapidTransactions[trxHash] = False

    log CancelRapidTransaction(trxHash, target, amount, signature, data, eta)

@payable
@external
def executeRapidTransaction(
    target: address,
    amount: uint256,
    signature: String[METHOD_SIG_SIZE],
    data: Bytes[CALL_DATA_LEN],
    eta: uint256
) -> Bytes[MAX_DATA_LEN]:
    """
    @notice
        executes a queued rapid transaction
    @param target The address of the contract to execute
    @param amount The amount of ether to send to the contract
    @param signature The signature of the function to execute
    @param data The data to send to the contract
    @param eta The timestamp when the transaction can be executed

    @return response The response from the transaction
    """
    assert msg.sender == self.leanTrack, "!leanTrack"

    trxHash: bytes32 = keccak256(_abi_encode(target, amount, signature, data, eta))
    assert self.queuedRapidTransactions[trxHash], "!queued_trx"
    assert block.timestamp >= eta, "!eta"
    assert block.timestamp <= eta + GRACE_PERIOD, "!staled_trx"

    self.queuedRapidTransactions[trxHash] = False

    callData: Bytes[MAX_DATA_LEN] = b""

    if len(signature) == 0:
        # @dev use provided data directly
        callData = data
    else: 
        # @dev use signature + data
        sig_hash: bytes32 = keccak256(signature)
        func_sig: bytes4 = convert(slice(sig_hash, 0, 4), bytes4)
        callData = concat(func_sig, data)

    success: bool = False
    response: Bytes[MAX_DATA_LEN] = b""

    success, response = raw_call(
        target,
        callData,
        max_outsize=MAX_DATA_LEN,
        value=amount,
        revert_on_failure=False
    )

    assert success, "!trx_revert"

    log ExecuteRapidTransaction(trxHash, target, amount, signature, data, eta)

    return response


@external
@view
def GRACE_PERIOD() -> uint256:
    return GRACE_PERIOD